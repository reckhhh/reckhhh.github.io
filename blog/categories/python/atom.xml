<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Python | Black Mamba]]></title>
  <link href="http://reckhhh.github.io/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://reckhhh.github.io/"/>
  <updated>2015-04-30T01:27:45+08:00</updated>
  <id>http://reckhhh.github.io/</id>
  <author>
    <name><![CDATA[Chen Rui]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Python Notes III]]></title>
    <link href="http://reckhhh.github.io/blog/2015/04/30/python-notes-iii/"/>
    <updated>2015-04-30T01:04:15+08:00</updated>
    <id>http://reckhhh.github.io/blog/2015/04/30/python-notes-iii</id>
    <content type="html"><![CDATA[<h3>Sort in two ways</h3>

<ul>
<li><strong>sort()</strong>: In-place sorting, <em>replaces</em> the original data</li>
<li><strong>sorted()</strong>: Copied sorting, return a <em>sorted copy</em> of the original data</li>
<li><p>sorting order
<code>
sorted(data)    // ascending
sorted(data, reverse=True)  //descending
</code></p></li>
<li><p>Get top 3 data from file
&#8220;`
def sanitize(time_string):
  if &lsquo;-&rsquo; in time_string:
      splitter = &lsquo;-&rsquo;
  elif &lsquo;:&rsquo; in time_string:
      splitter = &lsquo;:&rsquo;
  else:
      return (time_string)</p>

<p>  (mins, secs) = time_string.split(splitter)
  return (mins + &lsquo;.&rsquo; + secs)</p></li>
</ul>


<p>def get_data(filename):
    try:
        with open(filename) as file:
            data = file.readline()
        return data.strip().split(&lsquo;,&rsquo;)
    except IOError as ioerr:
        print(&lsquo;File error: &rsquo; + str(ioerr))
        return(None)</p>

<h1>file operation</h1>

<p>james = get_data(&lsquo;james.txt&rsquo;)</p>

<p>clean_james = []
for each_t in james:
    clean_james.append(sanitize(each_t))</p>

<p>unique_james = []
for each_t in clean_james:
    if each_t not in unique_james:
        unique_james.append(each_t)
print(sorted(unique_james)[0:3])
&#8220;`</p>

<ul>
<li><p>Remove the duplicates
&#8220;`</p>

<h1>file operation can be replaced with one line code</h1>

<p>print(sorted(set([sanitize(each_t) for each_t in get_date(&lsquo;james.txt&rsquo;)]))[0:3])
&#8220;`</p></li>
<li><p>Bundle the code and data in a dictionary
&#8220;`
def get_data(filename):
  try:
      with open(filename) as file:
          data = file.readline()
      temp = data.strip().split(&lsquo;,&rsquo;)</p>

<pre><code>  # return a dictionary
  return({'Name' : temp.pop(0),
          'DOB'  : temp.pop(0),
          'Times': str(sorted(set([sanitize(each_t) for each_t in temp]))[0:3])})
  except IOError as ioerr:
      print('File error: ' + str(ioerr))
      return(None)
</code></pre></li>
</ul>


<p>sarah = get_data(&lsquo;sarah2.txt&rsquo;)
print(sarah[&lsquo;Name&rsquo;] + &ldquo;&rsquo;s fastest times are: &rdquo; + sarah[&lsquo;Times&rsquo;])
&#8220;`</p>

<ul>
<li>Amend the code and data in a class that inherit from BIF <strong>list</strong>
&#8220;`
class Athlete(list):
  def <strong>init</strong>(self, a_name, a_dob=None, a_times=[]):
      list.<strong>init</strong>([])
      self.name = a_name
      self.dob = a_dob
      self.extend(a_times)</li>
</ul>


<p>def top3(self):
    return(str(sorted(set([sanitize(each_t) for each_t in self]))[0:3]))</p>

<p>def get_data(filename):
    try:
        &hellip;
        return(Athlete(temp.pop(0), temp.pop(0), temp))
    except IOError as ioerr:
        &hellip;</p>

<p>sarah = get_data(&lsquo;sarah2.txt&rsquo;)
print(sarah.name + &ldquo;&rsquo;s fastest times are: &rdquo; + sarah.top3())
&#8220;`</p>

<h3>Model the data</h3>

<ul>
<li>Put class AthleteList in a module file
&#8220;`
import pickle

<h1>class AthleteList is saved in athletelist.py, import AthleteList using this line of code</h1>

<h1>use dir() command to confirm that the import has been successful</h1>

<p>from athletelist import AthleteList</p></li>
</ul>


<p>def get_data(filename):
    &hellip;</p>

<p>def put_to_store(file_list):
    all_athletes = {}
    for each_file in file_list:
        ath = get_data(each_file)
        all_athletes[ath.name] = ath
    try:
        with open(&lsquo;athletes.pickle&rsquo;, &lsquo;wb&rsquo;) as athf:
            pickle.dump(all_athletes, athf)
    except IOError as ioerr:
        print(&lsquo;File error (put_and_store): &rsquo; + str(ioerr))
        return (all_athletes)</p>

<p>def get_from_store():
    all_athletes = {}
    try:
        with open(&lsquo;athletes.pickle&rsquo;, &lsquo;rb&rsquo;) as athf:
            all_athletes = pickle.load(athf)
        except IOError as ioerr:
            print(&lsquo;File error (get_from_store): &rsquo; + str(ioerr))
            return (all_athletes)
&#8220;`</p>

<p>-</p>

<hr />

<h3>Bonus I: Factory Function: set()</h3>

<ul>
<li>Build an unordered collection of unique elements
&#8220;`
data = [1,1,13,3,3,2,2,3,1,13,1]
set(data)

<h1>output</h1>

<p>{1, 2, 3, 13}
&#8220;`</p></li>
</ul>


<h3>Bonus II: BIF: pop(i)</h3>

<ul>
<li>pop(i) call returns and removes data from the front of a list at location &ldquo;i = 0 : n - 1&rdquo;
&#8220;`
data = [1,13,3,3,1]
data.pop(3)

<h1>output</h1>

<p>3
data
[1,13,3,1]
&#8220;`</p></li>
</ul>


<h3>Bonus III: List Comprehension</h3>

<ul>
<li>When the code is like this
<code>
new = []
for each_item in old:
  ...
append(len(each_item))
</code></li>
<li>Rewrite it like this
<code>
new = [len(each_item) for each_item in old]
</code></li>
</ul>


<h3>Bonus IV: Dictionary</h3>

<ul>
<li>Two way to create an empty dictionary
&#8220;`

<h1>method 1</h1>

d1 = {}

<h1>method 2</h1>

<p>d2 = dict()
&#8220;`</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python Notes II]]></title>
    <link href="http://reckhhh.github.io/blog/2015/04/28/python-notes-ii/"/>
    <updated>2015-04-28T22:29:26+08:00</updated>
    <id>http://reckhhh.github.io/blog/2015/04/28/python-notes-ii</id>
    <content type="html"><![CDATA[<h3>Operation for text</h3>

<ul>
<li><p>Open and close a file
<code>
the_file = open('sketch.txt')
the_file.close()
</code></p></li>
<li><p>Get and change the current working directory
<code>
import os
os.getcwd()
os.chdir('.../targetDirectory')
os.listdir()
</code></p></li>
<li><p>Read line and back to the start location of the file
<code>
data = open('sketch.txt')
print(data.readline(), end='')
data.seek(0)    // “rewind” a file to the beginning
</code></p></li>
<li><p>Process every line of a file
<code>
for eachLine in data:
  print(eachLine, end='')
</code></p></li>
<li><p>Using <em>split()</em> method to process each line to <em>extract</em> part of the line
&#8220;`
import os</p></li>
</ul>


<p>if os.path.exists(&lsquo;sketch.txt&rsquo;):
    data = open(&lsquo;sketch.txt&rsquo;)</p>

<p>for eachLine in data:
    # only process the line that contains &lsquo;:&rsquo;
    if not eachLine.find(&lsquo;:&rsquo;) == -1:
        # optional arg is set to 1, line of data is only broken into 2 pieces
        (role, line_spoken) = eachLine.split(&lsquo;:&rsquo;, 1)
        line_spoken = line_spoken.strip()</p>

<pre><code>    print(role, end='')
    print(' said: ', end='')
    print(line_spoken, end='')

data.close()
</code></pre>

<p>else:
    print(&lsquo;The data file is missing!&rsquo;)
&#8220;`</p>

<h3>Handle Exceptions: try/except Machanism</h3>

<ul>
<li><p>Python try to run code first, then deal with runtime errors (exceptions) as they happen
<code>
try:
  code (which might cause a runtime error)
except ErrorType:
  error-recovery code
</code></p></li>
<li><p>Python catch exceptions as they occur, gives you a chance to possibly recover from the error and, critically, not crash
&#8220;`
try:
  data = open(&lsquo;sketch.txt&rsquo;)</p>

<p>  for eachLine in data:
  try:
      (role, spoken) = eachLine.split(&lsquo;:&rsquo;, 1)
      line_spoken = line_spoken.strip()</p>

<pre><code>  print(role, end='')
  print(' said: ', end='')
  print(spoken, end='')
</code></pre>

<p>  # for handling the case there is no &lsquo;:&rsquo; in a line
  except ValueError:
      pass</p>

<p>  data.close()
except IOError:
  print(&lsquo;The data file is missing!&rsquo;)</p></li>
</ul>


<pre><code>
### Extend try/except with finally
- No matter what errors occur, code in the **finally** suite is always run
</code></pre>

<p>man = []
other = []</p>

<p>try:
    data = open(&lsquo;sketch.txt&rsquo;)</p>

<pre><code>for eachLine in data:
try:
    (role, spoken) = eachLine.split(':', 1)
    spoken = spoken.strip()

    if role == 'Man':
        man.append(spoken)
    elif role == 'Other Man':
        other.append(spoken)
    except ValueError:
        pass

data.close()
</code></pre>

<p>except IOError:
    print(&lsquo;The data file is missing!&rsquo;)</p>

<p>try:
    man_file = open(&lsquo;man_data.txt&rsquo;, &lsquo;w&rsquo;)
    other_file = open(&lsquo;other_data.txt&rsquo;, &lsquo;w&rsquo;)
    print(man, file=man_file)
    print(other, file=other_file)
except IOError as err:
    print(&lsquo;File Error: &rsquo; + str(err))
finally:
    if &lsquo;man_file&rsquo; in locals():
        man_file.close()
    if &lsquo;other_file&rsquo; in locals():
        other_file.close()
&#8220;`</p>

<h3>Knowing the detailed error imformation</h3>

<ul>
<li>Python creates an exception object that is passed as an argument to the except suite
&#8220;`
try:
  data = open(&lsquo;missingFile.txt&rsquo;)
      print(data.readline(), file=data)

<h1>the error imformation is named as &lsquo;err&rsquo;</h1>

<p>except IOError as err:
  print(&lsquo;File error: &rsquo; + str(err))
finally:
  if &lsquo;data&rsquo; in locals():
      data.close()</p></li>
</ul>


<h1>output:</h1>

<p>File error: [Errno 2] No such file or directory: &lsquo;missingFile.txt&rsquo;
&#8220;`</p>

<h3>Use with to reduce the amount of code</h3>

<ul>
<li><p>The following code is identical to the former as a short version
<code>
try:
  with open('missingFile.txt', "w") as data:
      print(data.readline(), file=data)
except IOError as err:
  print('File error: ' + str(err))
</code></p></li>
<li><p>try/except/finally code can be rewrite using <strong>with</strong>
<code>
try:
  with open('man_data.txt', 'w') as man_file, open('other_data.txt', 'w') as other_file:
      print(man, file=man_file)
      print(other, file=other_file)
except IOError as err:
  print('File error: ' + str(err))
</code></p></li>
<li><p><strong>Note</strong>: no need to close file, because <strong>with</strong> does that job</p></li>
</ul>


<h3>Open the file in write mode</h3>

<ul>
<li>Assume there is a file named &ldquo;example.txt&rdquo; in the current directory
<code>
out = open("example.txt", "w")
print("Write something to example.txt", file=out)
out.close()
</code></li>
</ul>


<h3>Update nester.py for formating the output files</h3>

<ul>
<li>Add the 4th argument (<strong>fh=sys.out</strong>) be the output file
&#8220;`

<h1>nester.py</h1>

<p>import sys</p></li>
</ul>


<p>def print_item (the_list, indent=False, level=0, fh=sys.stdout):
    for each_item in the_list:
        if isinstance(each_item, list):
            print_item (each_item, indent, level+1, fh)
        else:
            if indent:
                for tab_stop in range(level):
                    print(&ldquo;\t&rdquo;, end=&lsquo;@!&rsquo;, file=fh)
            print (each_item, file=fh)
&#8220;`</p>

<ul>
<li>Using func <strong>print_item</strong> for formating the output file
&#8220;`
import nester</li>
</ul>


<p>man = []
other = []</p>

<p>try:
    data = open(&lsquo;sketch.txt&rsquo;)</p>

<p>for eachLine in data:
    try:
        (role, line_spoken) = eachLine.split(&lsquo;:&rsquo;, 1)
        line_spoken = line_spoken.strip()</p>

<pre><code>    if role == 'Man':
        man.append(line_spoken)
    elif role == 'Other Man':
        other.append(line_spoken)
except ValueError:
    pass
data.close()
</code></pre>

<p>except IOError:
    print(&lsquo;The data file is missing!&rsquo;)</p>

<p>try:
    with open(&lsquo;man_data.txt&rsquo;, &lsquo;w&rsquo;) as man_file, open(&lsquo;other_data.txt&rsquo;, &lsquo;w&rsquo;) as other_file:
    # format the output files
    nester.print_item(man, fh=man_file)
    nester.print_item(other, fh=other_file)
except IOError as err:
    print(&lsquo;File error: &rsquo; + str(err))
&#8220;`</p>

<h3>Pickle the data</h3>

<ul>
<li>Store data using pickle.dump()
&#8220;`
import pickle</li>
</ul>


<p>man = []
other = []</p>

<p>try:
    &hellip;
except IOError:
    &hellip;</p>

<p>try:
    # &lsquo;wb&rsquo; indicate the access mode to be &ldquo;writeable, binary&rdquo;
    with open(&lsquo;man_data.txt&rsquo;, &lsquo;wb&rsquo;) as man_file, open(&lsquo;other_data.txt&rsquo;, &lsquo;wb&rsquo;) as other_file:
    # store data
        pickle.dump(man, man_file)
        pickle.dump(other, other_file)
except IOError as err:
    print(&lsquo;File error: &rsquo; + str(err))</p>

<h1>handle pickle exceptions</h1>

<p>except pickle.PickleError as perr:
    print(&lsquo;Pickling error: &rsquo; + str(perr))
<code>
- Load data using pickle.load()
</code>
import pickle
import nester</p>

<p>new_man = []</p>

<p>try:
    with open(&lsquo;man_data.txt&rsquo;, &lsquo;rb&rsquo;) as man_file:
        new_man = pickle.load(man_file)
except IOError as err:
    print(&lsquo;File error: &rsquo; + str(err))
except pickle.PickleError as perr:
    print(&lsquo;Pickle error: &rsquo; + str(perr))</p>

<p>nester.print_item(new_man)
&#8220;`</p>

<hr />

<h3>Bonus I: BIF split()</h3>

<ul>
<li>split(&hellip;)
<code>
str.split([sep[, maxsplit]]) -&gt; list of strings
</code></li>
<li>Return a list of the words in str, using <em>sep</em> as the delimiter string</li>
<li>If maxsplit is given, at most maxsplit splits are done</li>
<li>If <em>sep</em> is not specified or is None, any <strong>whitespace</strong> string is a separator and empty strings are removed from the results</li>
<li>If the <strong>optional argument</strong> is set to 1, line of data is only broken into 2 pieces, effectively negating the effect of any extra colon on any line</li>
</ul>


<h3>Bonus II: BIF strip()</h3>

<ul>
<li>strip(&hellip;)
<code>
str = "!!!!Today is a good day...Yeah.!!!!!!"
str.strip('!')
'Today is a good day...Yeah.'
</code></li>
<li>Returns a copy in which all chars have been stripped at the beginning and the end</li>
</ul>


<h3>Bonus III: BIFs Recall</h3>

<ul>
<li>open()</li>
<li>close()</li>
<li>readline()</li>
<li>seek()</li>
<li>split()</li>
<li>strip()</li>
<li>find()</li>
<li>help()</li>
<li>not</li>
<li>pass</li>
<li>pickle.dump()</li>
<li>pickle.load()</li>
<li>sys.out</li>
<li>try/except/finally</li>
<li>with &hellip; as</li>
<li>ValueError: Occurs when data doesn&rsquo;t conform to an expected format</li>
<li>IOError: Occurs when data can&rsquo;t be accessed properly</li>
</ul>


<h3>Bonus IV: Python Variable</h3>

<ul>
<li>Python variables don&rsquo;t actually contain the data assigned to them</li>
<li>Python variables contain a reference to a data object</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python Notes I]]></title>
    <link href="http://reckhhh.github.io/blog/2015/04/27/python-notes-i/"/>
    <updated>2015-04-27T12:28:38+08:00</updated>
    <id>http://reckhhh.github.io/blog/2015/04/27/python-notes-i</id>
    <content type="html"><![CDATA[<h3>Work effectively with IDLE</h3>

<ul>
<li>Press <strong>TAB</strong> key, IDLE will offer suggestions to help you complete your statement</li>
<li>Press <strong>Alt-P</strong> to recall the previous code statement and press <strong>Alt-N</strong> to move to the next code statement</li>
</ul>


<h3>Deal with Python list</h3>

<ul>
<li>Python&rsquo;s variable identifiers don&rsquo;t have a type, Python&rsquo;s list is a <strong>high-level collection</strong></li>
<li>Using print() and len() to work out how many data items are in the list
<code>
animal  = ["Dog", 'Pig', 'Cat', "Duck"]
print(animal)
['Dog', 'Pig', 'Cat', 'Duck']
print(len(animal))
4
print(animal[1])
Pig
</code></li>
<li>Using append(), extend() and pop() method to add and remove data from the list
<code>
animal.append("Tiger")
print(animal)
['Dog', 'Pig', 'Cat', 'Duck', 'Tiger']
animal.pop()
'Tiger'
print(animal)
['Dog', 'Pig', 'Cat', 'Duck']
animal.extend(["Fish", "Bird"])
print(animal)
['Dog', 'Pig', 'Cat', 'Duck', 'Fish', 'Bird']
</code></li>
<li><p>Using remove() and insert() to find and remove or add a <strong>specific</strong> data from list
<code>
animal.remove("Pig")
print(animal)
['Dog', 'Cat', 'Duck', 'Fish', 'Bird']
animal.insert(1, "Bull")
print(animal)
['Dog', 'Bull', 'Cat', 'Duck', 'Fish', 'Bird']
</code></p></li>
<li><p>For loops work with lists of any size
<code>
animals = ["Dog", 'Pig', 'Cat', "Duck", "Fish"]
for each_animal in animals:
  print each_animal
</code></p></li>
<li><p>Store list within lists
&#8220;`
movie = [&ldquo;Titanic&rdquo;, 1997, &ldquo;Romance &amp; Disaster&rdquo;, &ldquo;194 minutes&rdquo;, [&ldquo;James Cameron&rdquo;, [&ldquo;Leonardo DiCaprio&rdquo;, &ldquo;Kate Winslet&rdquo;, &ldquo;Billy Zane&rdquo;, &ldquo;Kathy Bates&rdquo;, &ldquo;Frances Fisher&rdquo;]]]
for each_item in movie:
  print each_item</p></li>
</ul>


<p>Titanic
1997
Romance &amp; Disaster
194 minutes
[&lsquo;James Cameron&rsquo;, [&lsquo;Leonardo DiCaprio&rsquo;, &lsquo;Kate Winslet&rsquo;, &lsquo;Billy Zane&rsquo;, &lsquo;Kathy Bates&rsquo;, &lsquo;Frances Fisher&rsquo;]]</p>

<p>print movie[4][1][0]
Leonardo DiCaprio
&#8220;`</p>

<h3>Don&rsquo;t repeat code and create a function</h3>

<ul>
<li>isinstance() BIF checks whether an identifier refers to a data object of some specified type</li>
<li>Using <strong>def</strong> to define a custom function
<code>
def function_name (arguments):
  code suite
</code></li>
<li>Python3 defaults its recursion limit to 1,000</li>
<li>Print items in list within lists
&#8220;`
def print_item(the_list):
  for each_item in the_list:
      if isinstance(each_item, list):
          print_item(each_item)
      else:
          print(each_item)</li>
</ul>


<p>print_item(movie)</p>

<p>Titanic
1997
Romance &amp; Disaster
194 minutes
James Cameron
Leonardo DiCaprio
Kate Winslet
Billy Zane
Kathy Bates
Frances Fisher
&#8220;`</p>

<h3>Build a distribution and upload code to PyPI</h3>

<ul>
<li>Create a folder for the module</li>
<li>Create a file called &ldquo;setup.py&rdquo; in the new folder
&#8220;`
from distutils.core import setup</li>
</ul>


<p>setup(
    name = &lsquo;nester&rsquo;,
    version = &lsquo;1.0&rsquo;,
    py_modules = [&lsquo;nester&rsquo;],
    author = &lsquo;name&rsquo;,
    author_email = &lsquo;<a href="&#109;&#97;&#105;&#x6c;&#116;&#111;&#58;&#x6e;&#97;&#109;&#x65;&#x40;&#x73;&#111;&#x6d;&#101;&#119;&#x68;&#x65;&#x72;&#x65;&#46;&#x63;&#111;&#x6d;">&#110;&#97;&#109;&#x65;&#64;&#x73;&#x6f;&#109;&#x65;&#119;&#104;&#101;&#x72;&#x65;&#46;&#x63;&#111;&#x6d;</a>&rsquo;,
    url = &lsquo;<a href="&#109;&#97;&#105;&#x6c;&#116;&#x6f;&#58;&#x6e;&#97;&#109;&#101;&#64;&#x73;&#x6f;&#109;&#101;&#112;&#108;&#x61;&#x63;&#101;&#46;&#x63;&#111;&#109;">&#110;&#x61;&#109;&#101;&#x40;&#x73;&#111;&#109;&#x65;&#x70;&#108;&#97;&#x63;&#101;&#46;&#99;&#111;&#109;</a>&rsquo;,
    description = &lsquo;A simple printer of nested lists&rsquo;,
    )
<code>
- Build a distribution file, enter the command at the prompt
</code>
python3 setup.py sdist
<code>
- Install the distribution into local copy of Python
</code>
python3 setup.py install
<code>
- Then, the module has been *transformed* into a distribution and *installed* into local copy of Python
</code>
// at the first time, should type the username and password
python3 setup.py register
&#8220;`</p>

<ul>
<li>Finally, upload code to PyPI
<code>
python3 setup.py sdist upload
</code></li>
</ul>


<h3>Import a module to use it</h3>

<ul>
<li>For instance, there is a function named &ldquo;nester.py&rdquo;
<code>
def print_item (the_list):
  # This function takes a argument called "the_list"
  for each_item in the_list:
      if isinstance(each_item, list):
          print_item (each_item)
      else:
          print (each_item)
</code></li>
<li>Type <strong>F5</strong> to run the module&rsquo;s code, use the following list data
<code>
// allow us to access nester's functions
import nester
animals = ['Pig', 'Dog', 'Cat', 'Bird', 'Fish']
// "nester" is associated namespace which like family names helps to qualify what the code mean
nester.print_item(animals)
</code></li>
</ul>


<h3>Use optional arguments</h3>

<ul>
<li>Update the function &ldquo;nester.py&rdquo; with default arguments
<code>
def print_item (the_list, indent=False, level=0):
  for each_item in the_list:
      if isinstance(each_item, list):
          print_item (each_item, indent, level+1)
      else:
          if indent:
              for tab_stop in range(level):
                  print("\t", end='@!')
          print (each_item)
</code></li>
<li>Use <strong>indent</strong> to control whether indent code</li>
<li>Use <strong>level</strong> to control the init indentation level</li>
</ul>


<h3>Update reversion to PyPI</h3>

<ul>
<li>Edit &ldquo;setup.py&rdquo; so that it has a new version
<code>
version = '1.1',
</code></li>
<li>Upload the new distribution to PyPI
<code>
python3 setup.py sdisk upload
</code></li>
</ul>


<hr />

<h3>Bonus I: Python BIFs</h3>

<ul>
<li>BIFs is short for <em>build-in functions</em>, it can mean less code to write</li>
<li>There were over 70 BIFs in Python3</li>
<li>BIFs have their very own namespace called <strong><em> builtins </em></strong></li>
<li>At Python or IDLE shell, typing dir(<strong><em> builtins </em></strong>) to see a list of the built-in functions</li>
<li>To find out what any BIF does—like input(), for example—type help(input) at the shell for a description of the BIFs function</li>
<li>Before write new code, think BIF at first</li>
</ul>


<h3>Bonus II: .pyc Files</h3>

<ul>
<li>If the module code hasn&rsquo;t changed, no translation occurs and the &ldquo;compiled&rdquo; code is executed</li>
<li>If the code has changed, the translation occurs (creating a new .pyc file) as needed</li>
<li>When Python sees a .pyc file, it tries to use it because doing so makes everything go much faster</li>
<li>The use of .pyc file (if found) is primarily a <strong>potential runtime optimization</strong> performed by the interpreter, it can&rsquo;t be created by users</li>
</ul>

]]></content>
  </entry>
  
</feed>
