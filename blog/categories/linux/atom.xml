<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Linux | Black Mamba]]></title>
  <link href="http://reckhhh.github.io/blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://reckhhh.github.io/"/>
  <updated>2015-06-18T23:16:30+08:00</updated>
  <id>http://reckhhh.github.io/</id>
  <author>
    <name><![CDATA[Chen Rui]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Linux Note III]]></title>
    <link href="http://reckhhh.github.io/blog/2015/06/18/linux-note-iii/"/>
    <updated>2015-06-18T23:10:58+08:00</updated>
    <id>http://reckhhh.github.io/blog/2015/06/18/linux-note-iii</id>
    <content type="html"><![CDATA[<ul>
<li><p>查询一个包是否被安装</p>

<ul>
<li>rpm -q | grep &lt; rpm package name></li>
</ul>
</li>
<li><p>列出所有被安装的 rpm package</p>

<ul>
<li>rpm -qa | grep <rpm package name></li>
</ul>
</li>
</ul>


<hr />

<ul>
<li><p>隐藏/显示 隐藏文件: Ctrl + h</p>

<ul>
<li>硬盘数据分为两个区域</li>
<li>主引导分区 (MBR, Master Boot Recorder): 放置这个硬盘的信息区，只有 4 个分区记录，这些记录被称为主分区和扩展分区(Extended)。一个磁盘最多可有 4 个(主 + 扩展)分区。其中，扩展分区只能有一个</li>
<li>引导程序
  磁盘分区表，分区即修改磁盘 MBR 里的分区表</li>
</ul>
</li>
<li><p>数据放置区, 实际文件数据放置的地方</p>

<ul>
<li>如分区超过 4 个，一定要有扩展分区，且必须将所有剩下的空间分给扩展分区，然后再以逻辑分区来规划扩展分区的空间</li>
</ul>
</li>
<li><p>关机 shutdown</p>

<ul>
<li>shutdown -h now, 立刻关机</li>
<li>shutdown -h 20：30, 定时关机</li>
<li>shutdown -h +10, 10分钟后关机</li>
<li>shutdown -r now, 立刻重启</li>
<li>shutdown -r +30 ‘The system will reboot’, 再过30分钟系统会重新启动，并显示后面的信息</li>
</ul>
</li>
<li><p>Linux 文件属性</p>

<ul>
<li>－rwxrwx&mdash;, 一个文件有 10 个属性</li>
<li>第一个属性表示这个文件是&#8221;目录, 文件或连接文件等&#8221;:</li>
</ul>
</li>
<li>[d], 目录</li>
<li>[-], 文件</li>
<li>[l], 连接文件 (link file)</li>
<li>[d], 设备文件中可供存储的接口设备</li>
<li><p>[c], 设备文件中的串行端口设备</p>

<ul>
<li>例1, drwxr&ndash;r&ndash;, 这时非 root 账号不可以进入该目录, 因为 x 与目录的关系相关重要, 如果在该目录下不能执行命令的话, 那么自然也就无法进入了. 因此, 如对他人开放某个目录, 记得开放该目录的 x 属性</li>
<li>例2, -rw-r&ndash;r&ndash;  1 root   root

<ul>
<li>拥有者为 root, 用户组为 root,只有 root 才有访问权</li>
</ul>
</li>
<li>例3, -rwxr-xr&ndash;  1 test1  testgroup

<ul>
<li>拥有者为 test1, 用户组为 testgroup, test1 对此文件具有可读, 可写, 可执行的权力; 而同组其他用户可读, 可执行, 但不能写; 非 testgroup 用户组的人则仅可读, 不能写, 不能执行</li>
</ul>
</li>
<li>例4, -rwxr-xr&ndash;  1 test1  testgroup

<ul>
<li>拥有者 test1 可在本目录中进行任何操作, testgroup 用户组的账号可以进入本目录进行操作, 但不能在本目录下写入; 其他权限虽然有 r, 但由于没有 x 权限, 因此不能进入此目录, <strong>x 与能否进入该目录有关</strong></li>
</ul>
</li>
<li><strong>w 可以让用户删除, 更新, 新建文件或目录</strong>

<ul>
<li>更改文件权限, 当复制文件的时候使用</li>
<li>chgrp: 改变文件所属于用户组</li>
<li>chown: 改变文件所有者</li>
<li>chmod: 改变文件的属性, 可使用数字或符号</li>
<li>当以 vi 编辑 shell 的文字后, 属性通常是 -rw-rw-rw-, 也就是 666, 如要将它变成可执行文件, 并不能让其他人修改此文件, 那么就需要 -rwxr-xr-x 这个 755 的属性, 使用 chmod 755 filename 命令</li>
</ul>
</li>
</ul>
</li>
<li><p>套接字 (sockets)</p>

<ul>
<li>通常用在网络数据连接. 可以启动一个程序监听客户端的要求, 客户段就可以通过套接字来进行数据通信</li>
</ul>
</li>
<li><p>cd -, 返回前一个工作目录</p></li>
<li><p>cd ~account, 返回 account 用户的家目录</p></li>
<li><p>[root@linux tmp]# cp -i ~/.bashrc bashhh, 将家目录下的 .bashrc 复制到 /tmp下, 并重命名为 bashhh</p></li>
<li><p>修改文件时间与创建新文件 touch</p>

<ul>
<li>touch -t 0507150202 bashrc</li>
<li>将 bashrc 日期修改为 2005/07/15 2:02</li>
</ul>
</li>
<li><p>文件权限掩码 umask</p>

<ul>
<li>普通用户为 002, root 用户为 022</li>
<li>&ldquo;文件&rdquo; 默认 &ldquo;没有 x 权限&rdquo;, 只有 rw (666)
-rw-rw-rw-</li>
<li>&ldquo;目录&rdquo; 中的 x 与是否可进入此目录有关, 因此默认开放所有权限, 即 rwx (777)</li>
<li>-rw-rw-rw-</li>
<li>umask -S
u=rwx,g=rx,o=rx</li>
<li>例如, umask 为 022, 当用户建立文件和目录时:</li>
<li>建立文件: (-rw-rw-rw-) - (&mdash;&ndash;w&ndash;w-) = (-rw-r&ndash;r&ndash;)</li>
<li>建立目录: (drwxrwxrwx) - (&mdash;&ndash;w&ndash;w-) = (drwxr-xr-x)</li>
</ul>
</li>
<li><p>搜索文件</p>

<ul>
<li>例如: 查找 client.c</li>
<li>locate client.c</li>
</ul>
</li>
<li><p>磁盘与目录的可用容量</p>

<ul>
<li>df -h</li>
<li>df -h /etc</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux Notes IV]]></title>
    <link href="http://reckhhh.github.io/blog/2015/06/17/linux-notes-iv/"/>
    <updated>2015-06-17T23:40:19+08:00</updated>
    <id>http://reckhhh.github.io/blog/2015/06/17/linux-notes-iv</id>
    <content type="html"><![CDATA[<h3>Linux 启动过程:</h3>

<ul>
<li>加载 BIOS 的硬件信息, 并获取第一个启动设备代号</li>
<li>读取第一个启动设备的 MBR 引导加载程序 (如 lilo, grub)</li>
<li>加载核心操作系统的核心信息, 核心开始解压缩, 并且尝试驱动所有硬件设备</li>
<li>核心执行 init 程序并获取运行信息</li>
<li>init 执行 /etc/rc.d/rc.sysinit 文件</li>
<li>启动核心的外挂模块 (/etc/modprobe.conf)</li>
<li>init 执行运行的各个批处理文件 (Scripts)</li>
<li>init 执行 /etc/rc.d/rc.local 文件</li>
<li>执行 /bin/login 程序, 等待用户登录</li>
<li>登录之后开始以 Shell 控制主机</li>
</ul>


<h3>引导加载程序 Grub:</h3>

<ul>
<li>引导加载程序是载入核心的工具</li>
<li>将引导加载程序分为两个阶段 (stage) 来执行

<ul>
<li>第一阶段为引导加载程序的主程序, 这个主程序必须要安装在启动区, 即 MBR 或超级块</li>
<li>第二阶段为载入引导加载程序的所有设置文件与相关的环境参数文件, 都在 /root 下面</li>
</ul>
</li>
<li>针对启动项目, 引导加载程序可以做到:

<ul>
<li>引导加载程序可以直接指定并取用核心文件, 加载到主存储器中</li>
<li>也可以将加载程序的控制权移交给下一个加载程序</li>
</ul>
</li>
<li>MBR 的 grub 可以做到:

<ul>
<li>直接指定核心 (boot/vmlinux) 来进行启动</li>
<li>将控制权交给 /dev/hda2 超级块中的 grub 进行管理</li>
</ul>
</li>
</ul>


<h3>Grub 的设置文件 /boot/grub/menu.1st 与安装类型:</h3>

<ul>
<li>Grub 启动时可自行编辑与修改启动设置项目, 类似 bash 的命令模式</li>
<li>可以动态搜索设置文件, 而不需要在修改设置文件后重新安装 grub, 即只要修改完 /boot/grub/menu.1st 里的设置, 下次启动就生效了</li>
<li>Grub 与硬盘的关系

<ul>
<li>grub 对硬盘的代号: (hd0, 0)</li>
<li>硬盘代号以小括号 () 括起来</li>
<li>硬盘以 hd 表示, 后面接一组数字</li>
<li>第一个搜索到的硬盘为 0 号, 第二个为 1 号,以此类推</li>
<li>第一个硬盘的第一个分区代号为 0, 以此类推</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Install Arm-linux-gcc on Linux]]></title>
    <link href="http://reckhhh.github.io/blog/2015/06/16/install-arm-linux-gcc-on-linux/"/>
    <updated>2015-06-16T23:39:55+08:00</updated>
    <id>http://reckhhh.github.io/blog/2015/06/16/install-arm-linux-gcc-on-linux</id>
    <content type="html"><![CDATA[<ul>
<li><p>下载 arm-linux-gcc-4.3.2.tg 包并解压到 /usr/local/ 目录下</p></li>
<li><p>配置 /etc/profile 全局环境变量, 在文件末尾加上:</p>

<ul>
<li><p>export PATH=$PATH:/usr/local/arm/4.3.2/bin</p></li>
<li><p>source /etc/profile</p></li>
</ul>
</li>
<li><p>配置成功后在命令行输入 arm-linux-gcc -v 命令查看版本信息</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ubuntu Install Software and Its Solution]]></title>
    <link href="http://reckhhh.github.io/blog/2015/06/15/ubuntu-install-software-and-its-solution/"/>
    <updated>2015-06-15T23:43:55+08:00</updated>
    <id>http://reckhhh.github.io/blog/2015/06/15/ubuntu-install-software-and-its-solution</id>
    <content type="html"><![CDATA[<p>When install a software, sometimes the following error will occur:</p>

<ul>
<li>E: Could not get lock /var/lib/dpkg/lock - open (11: Resource temporarily unavailable)</li>
<li>E: Unable to lock the administration directory (/var/lib/dpkg/), is another process using it?</li>
</ul>


<hr />

<p>This is the solution:</p>

<ul>
<li>sudo rm /var/cache/apt/archives/lock</li>
<li>sudo rm /var/lib/dpkg/lock</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Make Menuconfig Error and Solving Method]]></title>
    <link href="http://reckhhh.github.io/blog/2015/06/12/make-menuconfig-error-and-solving-method/"/>
    <updated>2015-06-12T00:46:02+08:00</updated>
    <id>http://reckhhh.github.io/blog/2015/06/12/make-menuconfig-error-and-solving-method</id>
    <content type="html"><![CDATA[<p>如使用 make menuconfig 配置内核，又碰巧系统没有安装 ncurses 库 (ubuntu系统
默认没有安装此库), 会出现错误:</p>

<p><strong><em> Unable to find the ncurses libraries or the
</em></strong> required header files.
*** &lsquo;make menuconfig&rsquo; requires the ncurses libraries.</p>

<hr />

<p>*** Install ncurses (ncurses-devel) and try again.</p>

<hr />

<p>make[1]: <strong><em> [scripts/kconfig/dochecklxdialog] Error 1
make: </em></strong> [menuconfig] Error 2</p>

<hr />

<p>解决方法, 安装ncurses库:
$sudo apt-get install libncurses5-dev</p>

<ul>
<li>ncurses库是字符终端下屏幕控制的基本库，可能很多新开发的程序都不使用了，不过如果要编译一些老程序，还经常用到</li>
</ul>

]]></content>
  </entry>
  
</feed>
